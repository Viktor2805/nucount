// // Package dna provides functionality for analyzing DNA sequences.
// package dna
// 
// import (
// 	"bufio"
// 	"fmt"
// 	"golang/internal/utils"
// 	"mime/multipart"
// 	"strings"
// )
// 
// // gcPrecision is the precision for rounding GC content percentage.
// var gcPrecision = 1
// 
// // BasesCount holds the counts of bases.
// type BasesCount struct {
// 	G, C, T, A int
// }
// 
// // BasesCounter is used to count the bases in a DNA sequence.
// type BasesCounter struct{}
// 
// // NewBasesCounter returns a new instance of BasesCounter.
// func NewBasesCounter() *BasesCounter {
// 	return &BasesCounter{}
// }
// 
// // CountBases reads the file line-by-line, processes each sequence,
// // and aggregates the base counts to calculate GC content.
// func (s *BasesCounter) CountBases(file multipart.File) (float64, error) {
// 	defer file.Close()
// 
// 	scanner := bufio.NewScanner(file)
// 	totalCounts := BasesCount{}
// 
// 	for scanner.Scan() {
// 		sequence := scanner.Text()
// 
// 		if strings.HasPrefix(sequence, ">") {
// 			continue
// 		}
// 
// 		counts := s.countSeqBases(sequence)
// 		totalCounts.G += counts.G
// 		totalCounts.C += counts.C
// 		totalCounts.T += counts.T
// 		totalCounts.A += counts.A
// 	}
// 
// 	if err := scanner.Err(); err != nil {
// 		return 0, fmt.Errorf("reading error: %w", err)
// 	}
// 
// 	totalGCCount := totalCounts.G + totalCounts.C
// 	totalSeqLength := totalGCCount + totalCounts.A + totalCounts.T
// 
// 	if totalSeqLength == 0 {
// 		return 0, nil
// 	}
// 
// 	gcPercentage := (float64(totalGCCount) / float64(totalSeqLength)) * 100
// 	gcContent := utils.Round(gcPercentage, gcPrecision)
// 
// 	return gcContent, nil
// }
// 
// // countSeqBases counts the number of bases (G, C, T, A) in a DNA sequence.
// // It uses an index loop to iterate over the bytes directly, which is faster
// // than decoding runes for ASCII-only sequences.
// func (s *BasesCounter) countSeqBases(sequence string) BasesCount {
// 	counts := BasesCount{}
// 	for i := 0; i < len(sequence); i++ {
// 		switch sequence[i] {
// 		case 'G':
// 			counts.G++
// 		case 'C':
// 			counts.C++
// 		case 'T':
// 			counts.T++
// 		case 'A':
// 			counts.A++
// 		}
// 	}
// 	return counts
// }
