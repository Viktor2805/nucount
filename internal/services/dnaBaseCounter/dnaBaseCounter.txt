// Package services provides functionality for analyzing DNA sequences.
package dna

import (
	"bufio"
	"context"
	"fmt"
	"mime/multipart"
	_ "net/http/pprof"
	"strings"

	"golang.org/x/sync/errgroup"
)

var (
	numWorkers = 5 // Concurrent gcCount workers
	// gcPrecision       = 1 // Precision for rounding GC content percentage
)

// BasesCount holds the counts of bases.
type BasesCount struct {
	G, C, T, A int
}

// BasesCounter is used to count the bases in a DNA sequence.
type BasesCounter struct{}

func NewBasesCounter() *BasesCounter {
	return &BasesCounter{}
}

// CountBases counts the GC content in the uploaded file.
func (s *BasesCounter) CountBases(file multipart.File) (BasesCount, error) {
	var (
		readTasksCh    = make(chan string, 1)
		countResultsCh = make(chan BasesCount, 1)
		errorCh        = make(chan error, 1)
		g, ctx         = errgroup.WithContext(context.Background())
	)

	g.Go(func() error {
		return s.reader(ctx, readTasksCh, file)
	})

	for i := 0; i < numWorkers; i++ {
		g.Go(func() error {
			return s.worker(ctx, readTasksCh, countResultsCh)
		})
	}

	go func() {
		defer close(countResultsCh)
		errorCh <- g.Wait()
	}()

	totalCounts := BasesCount{}
	for count := range countResultsCh {
		totalCounts.G += count.G
		totalCounts.C += count.C
		totalCounts.T += count.T
		totalCounts.A += count.A
	}

	if err := <-errorCh; err != nil {
		fmt.Println("Error in processing:", err)
	}

	return totalCounts, nil
}

// readDNASequences reads sequences from the file and sends them to the gcCount channel.
func (s *BasesCounter) reader(
	ctx context.Context,
	readTasksCh chan<- string,
	file multipart.File,
) error {
	defer close(readTasksCh)
	defer file.Close()

	scanner := bufio.NewScanner(file)

	for {
		if ctx.Err() != nil {
			return ctx.Err()
		}

		if !scanner.Scan() {
			if err := scanner.Err(); err != nil {
				return err
			}
			return nil
		}

		sequence := scanner.Text()

		if strings.HasPrefix(sequence, ">") {
			continue
		}

		readTasksCh <- sequence
	}
}

// gcCount processes sequences and sends the base count countResultsCh to the base count channel.
func (s *BasesCounter) worker(
	ctx context.Context,
	readTasksCh <-chan string,
	countResultsCh chan<- BasesCount,
) error {
	for {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case sequence, ok := <-readTasksCh:
			if !ok {
				return nil
			}

			counts := s.countSeqBases(sequence)
			countResultsCh <- counts
		}
	}
}

// countSeqBases counts the number of bases (G, C, T, A) in a DNA sequence.
func (s *BasesCounter) countSeqBases(sequence string) BasesCount {
	counts := BasesCount{}
	for _, base := range sequence {
		switch base {
		case 'G':
			counts.G++
		case 'C':
			counts.C++
		case 'T':
			counts.T++
		case 'A':
			counts.A++
		}
	}
	return counts
}
