package dna

import (
	"bytes"
	"io"
	"mime/multipart"
	"testing"

	"github.com/stretchr/testify/assert"
)

// MockMultipartFile is a mock implementation of multipart.File
type MockMultipartFile struct {
	multipart.File
	data *bytes.Buffer
}

// Read implements the io.Reader interface for MockMultipartFile
func (m *MockMultipartFile) Read(p []byte) (n int, err error) {
	n, err = m.data.Read(p)
	if err == io.EOF {
		return n, io.EOF
	}
	return n, err
}

// Seek resets the file pointer for re-reading
func (m *MockMultipartFile) Seek(offset int64, whence int) (int64, error) {
	if whence == io.SeekStart {
		m.data = bytes.NewBuffer(m.data.Bytes()) // Reset buffer
		return 0, nil
	}
	return 0, io.EOF
}

// Close implements the Close method for MockMultipartFile
func (m *MockMultipartFile) Close() error {
	return nil
}

func TestCountBases(t *testing.T) {
	tests := []struct {
		name        string
		fileContent string
		expected    float64
	}{
		{
			name:        "Simple GC Content",
			fileContent: ">seq1\nGCGCGC\n>seq2\nCGCGCG",
			expected:    100.0,
		},
		{
			name:        "Mixed Content",
			fileContent: ">seq1\nGCGCAT\n>seq2\nATGCAT",
			expected:    50.0,
		},
		{
			name:        "All A & T (0% GC)",
			fileContent: ">seq1\nATATAT\n>seq2\nTATAAA",
			expected:    0.0,
		},
		{
			name:        "Empty File",
			fileContent: "",
			expected:    0.0,
		},
		{
			name:        "Only Headers (No Sequences)",
			fileContent: ">seq1\n>seq2\n>seq3",
			expected:    0.0,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			file := &MockMultipartFile{
				data: bytes.NewBufferString(tt.fileContent),
			}

			basesCounter := NewBasesCounter()
			result, err := basesCounter.CountBases(file)

			assert.NoError(t, err)
			assert.Equal(t, tt.expected, result)
		})
	}
}
